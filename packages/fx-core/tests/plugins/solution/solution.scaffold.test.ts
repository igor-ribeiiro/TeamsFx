// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { it } from "mocha";
import { TeamsAppSolution } from " ../../../src/plugins/solution";
import {
  FxError,
  ok,
  PluginContext,
  Result,
  SolutionConfig,
  SolutionContext,
  Void,
  Plugin,
  Platform,
  v2,
  Inputs,
  AutoGeneratedReadme,
} from "@microsoft/teamsfx-api";
import * as sinon from "sinon";
import fs, { PathLike } from "fs-extra";
import { environmentManager } from "../../../src";
import {
  BotOptionItem,
  HostTypeOptionAzure,
  HostTypeOptionSPFx,
  MessageExtensionItem,
  TabOptionItem,
} from "../../../src/plugins/solution/fx-solution/question";
import _ from "lodash";
import path from "path";
import { getTemplatesFolder, newProjectSettings } from "../../../src";
import { newEnvInfo } from "../../../src/core/tools";
import {
  MockedLogProvider,
  MockedTelemetryReporter,
  MockedUserInteraction,
  validManifest,
} from "./util";
import * as uuid from "uuid";
import { ResourcePlugins } from "../../../src/plugins/solution/fx-solution/ResourcePluginContainer";
import Container from "typedi";
import mockedEnv from "mocked-env";
import { mockedFehostScaffoldArmResult, mockedSimpleAuthScaffoldArmResult } from "./util";
import { getQuestionsForScaffolding } from "../../../src/plugins/solution/fx-solution/v2/getQuestions";
import { MockTools } from "../../core/utils";
import { assert } from "console";
import { LocalCrypto } from "../../../src/core/crypto";
import { ArmTemplateResult } from "../../../src/common/armInterface";

chai.use(chaiAsPromised);
const expect = chai.expect;
const fehostPlugin = Container.get<Plugin>(ResourcePlugins.FrontendPlugin) as Plugin;
const simpleAuthPlugin = Container.get<Plugin>(ResourcePlugins.SimpleAuthPlugin) as Plugin;
const localdebugPlugin = Container.get<Plugin>(ResourcePlugins.LocalDebugPlugin);
const botPlugin = Container.get<Plugin>(ResourcePlugins.BotPlugin);
const spfxPlugin = Container.get<Plugin>(ResourcePlugins.SpfxPlugin);
const appStudioPlugin = Container.get<Plugin>(ResourcePlugins.AppStudioPlugin);
function mockSolutionContext(): SolutionContext {
  const config: SolutionConfig = new Map();
  return {
    root: ".",
    envInfo: newEnvInfo(),
    answers: { platform: Platform.VSCode },
    projectSettings: undefined,
    cryptoProvider: new LocalCrypto(""),
    ui: new MockedUserInteraction(),
    logProvider: new MockedLogProvider(),
    telemetryReporter: new MockedTelemetryReporter(),
  };
}

function mockScaffoldThatAlwaysSucceed(plugin: Plugin) {
  plugin.preScaffold = async function (_ctx: PluginContext): Promise<Result<any, FxError>> {
    return ok(Void);
  };
  plugin.scaffold = async function (_ctx: PluginContext): Promise<Result<any, FxError>> {
    return ok(Void);
  };
  plugin.postScaffold = async function (_ctx: PluginContext): Promise<Result<any, FxError>> {
    return ok(Void);
  };
}

describe("Solution scaffold() reading valid manifest file", () => {
  const mocker = sinon.createSandbox();
  const fileContent: Map<string, any> = new Map();
  const readmePath = path.join(getTemplatesFolder(), "plugins", "solution", "README.md");
  const mockedReadMeContent = "mocked readme content";
  const testFolder = "./tests/plugins/solution/testproject";
  beforeEach(async () => {
    await fs.ensureDir(testFolder);
    mocker.stub(fs, "writeFile").callsFake((path: number | PathLike, data: any) => {
      fileContent.set(path.toString(), data);
    });
    mocker.stub(fs, "writeJSON").callsFake((file: string, obj: any) => {
      fileContent.set(file, JSON.stringify(obj));
    });
    mocker.stub(fs, "readJson").resolves(validManifest);
    mocker.stub<any, any>(fs, "pathExists").withArgs(readmePath).resolves(true);
    mocker.stub(fs, "copy").callsFake((src: string, dest: string) => {
      fileContent.set(dest, mockedReadMeContent);
    });
    mocker.stub(fs, "appendFile").callsFake(async (path: number | PathLike, data: any) => {
      fileContent.set(path.toString(), data);
    });
  });

  afterEach(async () => {
    mocker.restore();
    await fs.remove(testFolder);
  });

  it("should work for happy path with only tab", async () => {
    fileContent.clear();
    const solution = new TeamsAppSolution();
    const mockedCtx = mockSolutionContext();
    mockedCtx.root = testFolder;
    mockedCtx.projectSettings = {
      appName: "my app",
      projectId: uuid.v4(),
      solutionSettings: {
        hostType: HostTypeOptionAzure.id,
        name: "azure",
        version: "1.0",
        activeResourcePlugins: [fehostPlugin.name],
        capabilities: [TabOptionItem.id],
        azureResources: [],
      },
    };
    mockScaffoldThatAlwaysSucceed(fehostPlugin);
    mockScaffoldThatAlwaysSucceed(localdebugPlugin);
    mocker.stub(environmentManager, "listEnvConfigs").resolves(ok(["dev"]));
    const result = await solution.scaffold(mockedCtx);
    expect(result.isOk()).to.be.true;
  });

  it("should work and generate README.md for happy path with tab and bot", async () => {
    fileContent.clear();
    const solution = new TeamsAppSolution();
    const mockedCtx = mockSolutionContext();
    mockedCtx.root = testFolder;
    mockedCtx.projectSettings = {
      appName: "my app",
      projectId: uuid.v4(),
      solutionSettings: {
        hostType: HostTypeOptionAzure.id,
        name: "azure",
        version: "1.0",
        activeResourcePlugins: [fehostPlugin.name, botPlugin.name],
        capabilities: [TabOptionItem.id, BotOptionItem.id],
        azureResources: [],
      },
    };
    mockScaffoldThatAlwaysSucceed(fehostPlugin);
    mockScaffoldThatAlwaysSucceed(botPlugin);
    mockScaffoldThatAlwaysSucceed(localdebugPlugin);
    mocker.stub(environmentManager, "listEnvConfigs").resolves(ok(["dev"]));
    const result = await solution.scaffold(mockedCtx);
    expect(result.isOk()).to.be.true;
    expect(fileContent.get(`${mockedCtx.root}/${AutoGeneratedReadme}`)).equals(mockedReadMeContent);
  });

  it("should work and generate README.md for happy path with tab and msgext", async () => {
    fileContent.clear();
    const solution = new TeamsAppSolution();
    const mockedCtx = mockSolutionContext();
    mockedCtx.root = testFolder;
    mockedCtx.projectSettings = {
      appName: "my app",
      projectId: uuid.v4(),
      solutionSettings: {
        hostType: HostTypeOptionAzure.id,
        name: "azure",
        version: "1.0",
        activeResourcePlugins: [fehostPlugin.name, botPlugin.name],
        capabilities: [TabOptionItem.id, MessageExtensionItem.id],
        azureResources: [],
      },
    };
    mockScaffoldThatAlwaysSucceed(fehostPlugin);
    mockScaffoldThatAlwaysSucceed(botPlugin);
    mockScaffoldThatAlwaysSucceed(localdebugPlugin);
    mocker.stub(environmentManager, "listEnvConfigs").resolves(ok(["dev"]));
    const result = await solution.scaffold(mockedCtx);
    expect(result.isOk()).to.be.true;
    expect(fileContent.get(`${mockedCtx.root}/${AutoGeneratedReadme}`)).equals(mockedReadMeContent);
  });

  it("should work and generate arm template when project requires Azure services", async () => {
    // add dedicated test case to test ARM feature enabled behavior
    const restore = mockedEnv({
      __TEAMSFX_INSIDER_PREVIEW: "1",
    });

    fileContent.clear();
    const solution = new TeamsAppSolution();
    const mockedCtx = mockSolutionContext();
    mockedCtx.root = testFolder;
    mockedCtx.projectSettings = {
      appName: "my app",
      projectId: uuid.v4(),
      solutionSettings: {
        hostType: HostTypeOptionAzure.id,
        name: "azure",
        version: "1.0",
        activeResourcePlugins: [simpleAuthPlugin.name],
        capabilities: [TabOptionItem.id],
        azureResources: [],
      },
    };
    mockScaffoldThatAlwaysSucceed(fehostPlugin);
    mockScaffoldThatAlwaysSucceed(simpleAuthPlugin);
    mockScaffoldThatAlwaysSucceed(localdebugPlugin);
    mockScaffoldThatAlwaysSucceed(appStudioPlugin);
    mocker.stub(environmentManager, "listEnvConfigs").resolves(ok(["dev"]));
    // mock plugin behavior
    mocker.stub(fehostPlugin, "generateArmTemplates").callsFake(async (ctx: PluginContext) => {
      const res: ArmTemplateResult = mockedSimpleAuthScaffoldArmResult();
      return ok(res);
    });

    mocker.stub(simpleAuthPlugin, "generateArmTemplates").callsFake(async (ctx: PluginContext) => {
      const res: ArmTemplateResult = mockedFehostScaffoldArmResult();
      return ok(res);
    });

    const result = await solution.scaffold(mockedCtx);
    expect(result.isOk()).to.be.true;
    // only need to check whether related files exist, tests to the content is covered by other test cases
    expect(fileContent.size).equals(6);
    expect(fileContent.has(path.join(testFolder, "./templates/azure", "provision.bicep"))).to.be
      .true;
    expect(fileContent.has(path.join(testFolder, "./templates/azure", "config.bicep"))).to.be.true;
    expect(
      fileContent.has(
        path.join(testFolder, "./templates/azure/provision", "frontendHostingProvision.bicep")
      )
    ).to.be.true;
    expect(
      fileContent.has(
        path.join(testFolder, "./templates/azure/provision", "simpleAuthProvision.bicep")
      )
    ).to.be.true;
    expect(fileContent.has(path.join(testFolder, "./templates/azure/provision", "identity.bicep")))
      .to.be.true;
    expect(fileContent.has(path.join(testFolder, "./.fx/configs", "azure.parameters.dev.json"))).to
      .be.true;

    restore();
  });

  it("should work and not generate arm template when project does not require Azure services", async () => {
    // add dedicated test case to test ARM feature enabled behavior
    const restore = mockedEnv({
      __TEAMSFX_INSIDER_PREVIEW: "1",
    });

    fileContent.clear();
    const solution = new TeamsAppSolution();
    const mockedCtx = mockSolutionContext();
    mockedCtx.root = testFolder;
    mockedCtx.projectSettings = {
      appName: "my app",
      projectId: uuid.v4(),
      solutionSettings: {
        hostType: HostTypeOptionSPFx.id,
        name: "spfx",
        version: "1.0",
        activeResourcePlugins: [spfxPlugin.name],
        capabilities: [TabOptionItem.id],
        azureResources: [],
      },
    };
    mockScaffoldThatAlwaysSucceed(spfxPlugin);
    mockScaffoldThatAlwaysSucceed(localdebugPlugin);
    mockScaffoldThatAlwaysSucceed(appStudioPlugin);

    const result = await solution.scaffold(mockedCtx);
    expect(result.isOk()).to.be.true;
    restore();
  });
  it("getQuestionsForScaffolding", async () => {
    const tools = new MockTools();
    const contextv2: v2.Context = {
      userInteraction: tools.ui,
      logProvider: tools.logProvider,
      telemetryReporter: tools.telemetryReporter!,
      cryptoProvider: tools.cryptoProvider!,
      permissionRequestProvider: tools.permissionRequestProvider!,
      projectSetting: newProjectSettings(),
    };
    const inputs: Inputs = { platform: Platform.CLI, projectPath: "." };
    const res = await getQuestionsForScaffolding(contextv2, inputs);
    assert(res.isOk());
  });
});
